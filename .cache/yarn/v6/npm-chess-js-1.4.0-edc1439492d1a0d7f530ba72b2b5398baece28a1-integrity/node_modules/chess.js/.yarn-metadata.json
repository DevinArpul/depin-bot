{
  "manifest": {
    "name": "chess.js",
    "version": "1.4.0",
    "license": "BSD-2-Clause",
    "main": "dist/cjs/chess.js",
    "module": "dist/esm/chess.js",
    "types": "dist/types/chess.d.ts",
    "homepage": "https://github.com/jhlywa/chess.js",
    "author": {
      "name": "Jeff Hlywa",
      "email": "jhlywa@gmail.com"
    },
    "scripts": {
      "prepare": "npm run build",
      "build": "npm run parser && tsc --noEmit && rollup -c",
      "check": "npm run format:check && npm run lint && npm run test && npm run build",
      "clean": "rm -rf ./dist; rm -f src/pgn.js src/pgn.d.ts",
      "format": "prettier --write .",
      "format:check": "prettier --check .",
      "lint": "eslint src/ --ext .ts",
      "parser": "peggy -c peggy.config.mjs",
      "test": "vitest",
      "test:coverage": "vitest --coverage",
      "bench": "tsx benchmarks/bench.ts"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/jhlywa/chess.js"
    },
    "devDependencies": {
      "@rollup/plugin-commonjs": "^28.0.3",
      "@rollup/plugin-typescript": "^12.1.2",
      "@typescript-eslint/eslint-plugin": "^5.17.0",
      "@typescript-eslint/parser": "^5.17.0",
      "@vitest/coverage-v8": "^3.2.2",
      "eslint": "^8.12.0",
      "peggy": "^4.2.0",
      "prettier": "^3.1.0",
      "rollup": "^4.41.1",
      "rollup-plugin-dts": "^6.2.1",
      "tinybench": "^4.0.1",
      "tslib": "^2.8.1",
      "tsx": "^4.19.4",
      "typescript": "^4.6.3",
      "vitest": "^3.2.2"
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-chess-js-1.4.0-edc1439492d1a0d7f530ba72b2b5398baece28a1-integrity/node_modules/chess.js/package.json",
    "readmeFilename": "README.md",
    "readme": "# chess.js\n\n[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/jhlywa/chess.js/node.js.yml)](https://github.com/jhlywa/chess.js/actions)\n[![npm](https://img.shields.io/npm/v/chess.js?color=blue)](https://www.npmjs.com/package/chess.js)\n[![npm](https://img.shields.io/npm/dm/chess.js)](https://www.npmjs.com/package/chess.js)\n\nchess.js is a TypeScript chess library used for chess move\ngeneration/validation, piece placement/movement, and check/checkmate/stalemate\ndetection - basically everything but the AI.\n\nchess.js has been extensively tested in node.js and most modern browsers.\n\n## Installation\n\nRun the following command to install the most recent version of chess.js from\nNPM:\n\n```sh\nnpm install chess.js\n```\n\n## Importing\n\n### Import (as ESM)\n\n```js\nimport { Chess } from 'chess.js'\n```\n\nECMAScript modules (ESM) can be directly imported in a browser:\n\n```html\n<script type=\"module\">\n  import { Chess } from 'chess.js'\n</script>\n```\n\n### Import (as CommonJS)\n\n```js\nconst { Chess } = require('chess.js')\n```\n\n## Example Code\n\nThe code below plays a random game of chess:\n\n```js\nimport { Chess } from 'chess.js'\n\nconst chess = new Chess()\n\nwhile (!chess.isGameOver()) {\n  const moves = chess.moves()\n  const move = moves[Math.floor(Math.random() * moves.length)]\n  chess.move(move)\n}\nconsole.log(chess.pgn())\n```\n\n## User Interface\n\nBy design, chess.js is a headless library and does not include user interface\nelements. Many developers have successfully integrated chess.js with the\n[chessboard.js](http://chessboardjs.com) library. See\n[chessboard.js - Random vs Random](http://chessboardjs.com/examples#5002) for an\nexample.\n\n## Parsers (permissive / strict)\n\nThis library includes two parsers (`permissive` and `strict`) which are used to\nparse different forms of chess move notation. The `permissive` parser (the\ndefault) is able to handle many non-standard derivatives of algebraic notation\n(e.g. `Nf3`, `g1f3`, `g1-f3`, `Ng1f3`, `Ng1-f3`, `Ng1xf3`). The `strict` parser\nonly accepts moves in Standard Algebraic Notation and requires that they\nstrictly adhere to the specification. The `strict` parser runs slightly faster\nbut will not parse any non-standard notation.\n\n## API\n\n### Constants\n\nThe following constants are exported from the top-level module:\n\n```ts\n// colors\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\n// pieces\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\n// starting position (in FEN)\nexport const DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\n// square list\nexport const SQUARES = ['a8', 'b8', 'c8', ..., 'f1', 'g1', 'h1']\n```\n\n### Constructor: Chess([ fen ], { skipValidation = false } = {})\n\nThe Chess() constructor creates a new chess object that default to the initial\nboard position. It accepts two optional parameters : a string which specifies\nthe board configuration in\n[Forsyth-Edwards Notation (FEN)](http://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation),\nand an object with a `skipValidation` boolean. By default the constructor will\nthrow an exception if an invalid FEN string is provided. This behavior can be\nskipped by setting the `skipValidation` boolean.\n\n```ts\nimport { Chess } from 'chess.js'\n\n// an empty constructor defaults the starting position\nlet chess = new Chess()\n\n// pass in a FEN string to load a particular position\nlet chess = new Chess(\n  'r1k4r/p2nb1p1/2b4p/1p1n1p2/2PP4/3Q1NB1/1P3PPP/R5K1 b - - 0 19',\n)\n\n// the white king is missing from the FEN string below\nlet chess = new Chess(\n  'r1k4r/p2nb1p1/2b4p/1p1n1p2/2PP4/3Q1NB1/1P3PPP/R52 b - - 0 19',\n  { skipValidation = true },\n)\n```\n\n### .ascii()\n\nReturns a string containing an ASCII diagram of the current position.\n\n```ts\nconst chess = new Chess()\n\n// make some moves\nchess.move('e4')\nchess.move('e5')\nchess.move('f4')\n\nchess.ascii()\n// -> '   +------------------------+\n//      8 | r  n  b  q  k  b  n  r |\n//      7 | p  p  p  p  .  p  p  p |\n//      6 | .  .  .  .  .  .  .  . |\n//      5 | .  .  .  .  p  .  .  . |\n//      4 | .  .  .  .  P  P  .  . |\n//      3 | .  .  .  .  .  .  .  . |\n//      2 | P  P  P  P  .  .  P  P |\n//      1 | R  N  B  Q  K  B  N  R |\n//        +------------------------+\n//          a  b  c  d  e  f  g  h'\n```\n\n### .attackers(square, [ color ])\n\nReturns a list of squares that have pieces belonging to the side to move that\ncan attack the given square. This function takes an optional parameter which can\nchange which color the pieces should belong to.\n\n```ts\nconst chess = new Chess()\n\nchess.attackers('f3')\n// -> ['e2', 'g2', 'g1'] (empty squares can be attacked)\n\nchess.attackers('e2')\n// -> ['d1', 'e1', 'f1', 'g1'] (we can attack our own pieces)\n\nchess.attackers('f6')\n// -> [] (squares not attacked by the side to move will return an empty list)\n\nchess.move('e4')\nchess.attackers('f6')\n// -> ['g8', 'e7', 'g7'] (return value changes depending on side to move)\n\nchess.attackers('f3', WHITE)\n// -> ['g2', 'd1', 'g1'] (side to move can be ignored by specifying a color)\n\nchess.load('4k3/4n3/8/8/8/8/4R3/4K3 w - - 0 1')\nchess.attackers('c6', BLACK)\n// -> ['e7'] (pieces still attack a square even if they are pinned)\n```\n\n### .board()\n\nReturns a 2D array representation of the current position. Empty squares are\nrepresented by `null`.\n\n```ts\nconst chess = new Chess()\n\nchess.board()\n// -> [[{square: 'a8', type: 'r', color: 'b'},\n//      {square: 'b8', type: 'n', color: 'b'},\n//      {square: 'c8', type: 'b', color: 'b'},\n//      {square: 'd8', type: 'q', color: 'b'},\n//      {square: 'e8', type: 'k', color: 'b'},\n//      {square: 'f8', type: 'b', color: 'b'},\n//      {square: 'g8', type: 'n', color: 'b'},\n//      {square: 'h8', type: 'r', color: 'b'}],\n//      [...],\n//      [...],\n//      [...],\n//      [...],\n//      [...],\n//      [{square: 'a1', type: 'r', color: 'w'},\n//       {square: 'b1', type: 'n', color: 'w'},\n//       {square: 'c1', type: 'b', color: 'w'},\n//       {square: 'd1', type: 'q', color: 'w'},\n//       {square: 'e1', type: 'k', color: 'w'},\n//       {square: 'f1', type: 'b', color: 'w'},\n//       {square: 'g1', type: 'n', color: 'w'},\n//       {square: 'h1', type: 'r', color: 'w'}]]\n```\n\n### .clear({ preserveHeaders = false } = {})\n\nClears the board.\n\n```ts\nchess.clear()\nchess.fen()\n// -> '8/8/8/8/8/8/8/8 w - - 0 1' <- empty board\n```\n\n### .fen({ forceEnpassantSquare = false) = {})\n\nReturns the FEN string for the current position. Note, the en passant square is\nonly included if the side-to-move can legally capture en passant.\n\nThe enpassant square will always be included if forceEnpassantSquare is true.\n\n```ts\nconst chess = new Chess()\n\n// make some moves\nchess.move('e4')\nchess.move('e5')\nchess.move('f4')\n\nchess.fen()\n// -> 'rnbqkbnr/pppp1ppp/8/4p3/4PP2/8/PPPP2PP/RNBQKBNR b KQkq - 0 2'\n```\n\n### .findPiece(piece)\n\nReturns a list containing the squares where the requested piece is located.\nReturns an empty list if the piece is not on the board.\n\n```ts\nconst chess = new Chess()\n\nchess.findPiece({ type: KING, color: BLACK })\n// -> ['e8']\nchess.findPiece({ type: BISHOP, color: WHITE })\n// -> ['c1', 'f1']\nchess.remove('d1')\nchess.findPiece({ type: QUEEN, color: WHITE })\n// -> []\n```\n\n### .get(square)\n\nReturns the piece on the square. Returns `undefined` if the square is empty.\n\n```ts\nchess.put({ type: PAWN, color: BLACK }, 'a5') // put a black pawn on a5\n\nchess.get('a5')\n// -> { type: 'p', color: 'b' },\nchess.get('a6')\n// -> undefined\n```\n\n### .getCastlingRights(color)\n\nGets the castling rights for the given color. An object is returned which\nindicates whether the right is available or not for both kingside and queenside.\nNote this does not indicate if such a move is legal or not in the current\nposition as checks etc. also need to be considered.\n\n```ts\nconst chess = new Chess()\n\nchess.getCastlingRights(BLACK) // black can castle queenside only\n// -> { 'k': false, 'q': true }\n```\n\n### .getComment()\n\nRetrieve the comment for the current position, if it exists.\n\n```ts\nconst chess = new Chess()\n\nchess.loadPgn('1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *')\n\nchess.getComment()\n// -> \"giuoco piano\"\n```\n\n### .getComments()\n\nRetrieve comments for all positions.\n\n```ts\nconst chess = new Chess()\n\nchess.loadPgn(\n  \"1. e4 e5 {king's pawn opening} 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *\",\n)\n\nchess.getComments()\n// -> [\n//     {\n//       fen: \"rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2\",\n//       comment: \"king's pawn opening\"\n//     },\n//     {\n//       fen: \"r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3\",\n//       comment: \"giuoco piano\"\n//     }\n//    ]\n```\n\n### .getHeaders()\n\nRetrieve the PGN headers.\n\n```ts\nchess.setHeader('White', 'Morphy')\nchess.setHeader('Black', 'Anderssen')\nchess.setHeader('Date', '1858-??-??')\nchess.getHeaders()\n// -> { White: 'Morphy', Black: 'Anderssen', Date: '1858-??-??' }\n```\n\n### .hash()\n\nReturns a unique 64-bit hash as a hexidecimal string for the current position.\n\n```ts\nchess.hash()\n// -> '3436f01fd716346e'\n```\n\n### .history([ options ])\n\nReturns a list containing the moves of the current game. Options is an optional\nparameter which may contain a 'verbose' flag. See .moves() for a description of\nthe verbose move fields. A FEN string of the position _prior_ to the move being\nmade is added to the verbose history output.\n\n```ts\nconst chess = new Chess()\nchess.move('e4')\nchess.move('e5')\nchess.move('f4')\nchess.move('exf4')\n\nchess.history()\n// -> ['e4', 'e5', 'f4', 'exf4']\n\nchess.history({ verbose: true })\n// -->\n// [\n//   {\n//     before: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',\n//     after: 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1',\n//     color: 'w',\n//     piece: 'p',\n//     from: 'e2',\n//     to: 'e4',\n//     san: 'e4',\n//     lan: 'e2e4',\n//   },\n//   {\n//     before: 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1',\n//     after: 'rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2',\n//     color: 'b',\n//     piece: 'p',\n//     from: 'e7',\n//     to: 'e5',\n//     san: 'e5',\n//     lan: 'e7e5',\n//   },\n//   {\n//     before: 'rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2',\n//     after: 'rnbqkbnr/pppp1ppp/8/4p3/4PP2/8/PPPP2PP/RNBQKBNR b KQkq - 0 2',\n//     color: 'w',\n//     piece: 'p',\n//     from: 'f2',\n//     to: 'f4',\n//     san: 'f4',\n//     lan: 'f2f4',\n//   },\n//   {\n//     before: 'rnbqkbnr/pppp1ppp/8/4p3/4PP2/8/PPPP2PP/RNBQKBNR b KQkq - 0 2',\n//     after: 'rnbqkbnr/pppp1ppp/8/8/4Pp2/8/PPPP2PP/RNBQKBNR w KQkq - 0 3',\n//     color: 'b',\n//     piece: 'p',\n//     from: 'e5',\n//     to: 'f4',\n//     san: 'exf4',\n//     lan: 'e5f4',\n//     captured: 'p'\n//   }\n// ]\n```\n\n### .inCheck()\n\nReturns true or false if the side to move is in check.\n\n```ts\nconst chess = new Chess(\n  'rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3',\n)\nchess.inCheck()\n// -> true\n```\n\n### .isAttacked(square, color)\n\nReturns true if the square is attacked by any piece of the given color.\n\n```ts\nconst chess = new Chess()\nchess.isAttacked('f3', WHITE)\n// -> true (we can attack empty squares)\n\nchess.isAttacked('f6', BLACK)\n// -> true (side to move (e.g. the value returned by .turn) is ignored)\n\nchess.load(DEFAULT_POSITION)\nchess.isAttacked('e2', WHITE)\n// -> true (we can attack our own pieces)\n\nchess.load('4k3/4n3/8/8/8/8/4R3/4K3 w - - 0 1')\nchess.isAttacked('c6', BLACK)\n// -> true (pieces still attack a square even if they are pinned)\n```\n\n### .isCheckmate()\n\nReturns true or false if the side to move has been checkmated.\n\n```ts\nconst chess = new Chess(\n  'rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3',\n)\nchess.isCheckmate()\n// -> true\n```\n\n### .isDraw()\n\nReturns true or false if the game is drawn (50-move rule or insufficient\nmaterial).\n\n```ts\nconst chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\nchess.isDraw()\n// -> true\n```\n\n### .isDrawByFiftyMoves()\n\nReturns true or false if the game is drawn by 50-move rule.\n\n```ts\nconst chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\nchess.isDrawByFiftyMoves()\n// -> true\n```\n\n### .isInsufficientMaterial()\n\nReturns true if the game is drawn due to insufficient material (K vs. K, K vs.\nKB, or K vs. KN) otherwise false.\n\n```ts\nconst chess = new Chess('k7/8/n7/8/8/8/8/7K b - - 0 1')\nchess.isInsufficientMaterial()\n// -> true\n```\n\n### .isGameOver()\n\nReturns true if the game has ended via checkmate, stalemate, draw, threefold\nrepetition, or insufficient material. Otherwise, returns false.\n\n```ts\nconst chess = new Chess()\nchess.isGameOver()\n// -> false\n\n// stalemate\nchess.load('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\nchess.isGameOver()\n// -> true\n\n// checkmate\nchess.load('rnb1kbnr/pppp1ppp/8/4p3/5PPq/8/PPPPP2P/RNBQKBNR w KQkq - 1 3')\nchess.isGameOver()\n// -> true\n```\n\n### .isStalemate()\n\nReturns true or false if the side to move has been stalemated.\n\n```ts\nconst chess = new Chess('4k3/4P3/4K3/8/8/8/8/8 b - - 0 78')\nchess.isStalemate()\n// -> true\n```\n\n### .isThreefoldRepetition()\n\nReturns true or false if the current board position has occurred three or more\ntimes.\n\n```ts\nconst chess = new Chess(\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',\n)\n// -> true\n// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 1st time\nchess.isThreefoldRepetition()\n// -> false\n\nchess.move('Nf3')\nchess.move('Nf6')\nchess.move('Ng1')\nchess.move('Ng8')\n// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 2nd time\nchess.isThreefoldRepetition()\n// -> false\n\nchess.move('Nf3')\nchess.move('Nf6')\nchess.move('Ng1')\nchess.move('Ng8')\n// rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq occurs 3rd time\nchess.isThreefoldRepetition()\n// -> true\n```\n\n### .load(fen: string, { skipValidation = false, preserveHeaders = false } = {})\n\nClears the board and loads the provided FEN string. The castling rights, en\npassant square and move numbers are defaulted to `- - 0 1` if omitted. Throws an\nexception if the FEN is invalid.\n\n```ts\nconst chess = new Chess()\nchess.load('4r3/8/2p2PPk/1p6/pP2p1R1/P1B5/2P2K2/3r4 w - - 1 45')\n\ntry {\n  chess.load('8/4p3/8/8/8/8/4P3/6K1 w - - 1 45')\n} catch (e) {\n  console.error(e)\n}\n// -> Error: Invalid FEN: missing black king\n\nchess.load('8/4p3/8/8/8/8/4P3/6K1 w - - 1 45', { skipValidation: true })\n// -> Works!\n```\n\n### .loadPgn(pgn, [ options ])\n\nLoad the moves of a game stored in\n[Portable Game Notation](http://en.wikipedia.org/wiki/Portable_Game_Notation).\n`pgn` should be a string. Options is an optional object which may contain a\nstring `newlineChar` and a boolean `strict`.\n\nThe `newlineChar` is a string representation of a valid RegExp fragment and is\nused to process the PGN. It defaults to `\\r?\\n`. Special characters should not\nbe pre-escaped, but any literal special characters should be escaped as is\nnormal for a RegExp. Keep in mind that backslashes in JavaScript strings must\nthemselves be escaped (see `sloppyPgn` example below). Avoid using a\n`newlineChar` that may occur elsewhere in a PGN, such as `.` or `x`, as this\nwill result in unexpected behavior.\n\nThe `strict` flag is a boolean (default: `false`) that instructs chess.js to\nonly parse moves in Standard Algebraic Notation form. See `.move` documentation\nfor more information about non-SAN notations.\n\nThe method will throw and exception if the PGN fails to parse.\n\n```ts\nconst chess = new Chess()\nconst pgn = [\n  '[Event \"Casual Game\"]',\n  '[Site \"Berlin GER\"]',\n  '[Date \"1852.??.??\"]',\n  '[EventDate \"?\"]',\n  '[Round \"?\"]',\n  '[Result \"1-0\"]',\n  '[White \"Adolf Anderssen\"]',\n  '[Black \"Jean Dufresne\"]',\n  '[ECO \"C52\"]',\n  '[WhiteElo \"?\"]',\n  '[BlackElo \"?\"]',\n  '[PlyCount \"47\"]',\n  '',\n  '1.e4 e5 2.Nf3 Nc6 3.Bc4 Bc5 4.b4 Bxb4 5.c3 Ba5 6.d4 exd4 7.O-O',\n  'd3 8.Qb3 Qf6 9.e5 Qg6 10.Re1 Nge7 11.Ba3 b5 12.Qxb5 Rb8 13.Qa4',\n  'Bb6 14.Nbd2 Bb7 15.Ne4 Qf5 16.Bxd3 Qh5 17.Nf6+ gxf6 18.exf6',\n  'Rg8 19.Rad1 Qxf3 20.Rxe7+ Nxe7 21.Qxd7+ Kxd7 22.Bf5+ Ke8',\n  '23.Bd7+ Kf8 24.Bxe7# 1-0',\n]\n\nchess.loadPgn(pgn.join('\\n'))\n\nchess.ascii()\n// -> '  +------------------------+\n//     8 | .  r  .  .  .  k  r  . |\n//     7 | p  b  p  B  B  p  .  p |\n//     6 | .  b  .  .  .  P  .  . |\n//     5 | .  .  .  .  .  .  .  . |\n//     4 | .  .  .  .  .  .  .  . |\n//     3 | .  .  P  .  .  q  .  . |\n//     2 | P  .  .  .  .  P  P  P |\n//     1 | .  .  .  R  .  .  K  . |\n//       +------------------------+\n//         a  b  c  d  e  f  g  h'\n\n// Parse non-standard move formats and unusual line separators\nconst sloppyPgn = [\n  '[Event \"Wijk aan Zee (Netherlands)\"]',\n  '[Date \"1971.01.26\"]',\n  '[Result \"1-0\"]',\n  '[White \"Tigran Vartanovich Petrosian\"]',\n  '[Black \"Hans Ree\"]',\n  '[ECO \"A29\"]',\n  '',\n  '1. Pc2c4 Pe7e5', // non-standard\n  '2. Nc3 Nf6',\n  '3. Nf3 Nc6',\n  '4. g2g3 Bb4', // non-standard\n  '5. Nd5 Nxd5',\n  '6. c4xd5 e5-e4', // non-standard\n  '7. dxc6 exf3',\n  '8. Qb3 1-0',\n].join(':')\n\nchess.loadPgn(sloppyPgn, { newlineChar: ':' })\n// works by default\n\nchess.loadPgn(sloppyPgn, { newlineChar: ':', strict: true })\n// Error: Invalid move in PGN: Pc2c4\n```\n\n### .move(move, [ options ])\n\nMakes a move on the board and returns a move object if the move was legal. The\nmove argument can be either a string in Standard Algebraic Notation (SAN) or a\nmove object. Throws an 'Illegal move' exception if the move was illegal.\n\n#### .move() - Standard Algebraic Notation (SAN)\n\n```ts\nconst chess = new Chess()\n\nchess.move('e4')\n// -> { color: 'w', from: 'e2', to: 'e4', piece: 'p', san: 'e4' }\n\nchess.move('nf6') // SAN is case sensitive!!\n// Error: Invalid move: nf6\n\nchess.move('Nf6')\n// -> { color: 'b', from: 'g8', to: 'f6', piece: 'n', san: 'Nf6' }\n```\n\n#### .move() - Object Notation\n\nA move object contains `to`, `from` and, `promotion` (only when necessary)\nfields.\n\n```ts\nconst chess = new Chess()\n\nchess.move({ from: 'g2', to: 'g3' })\n// -> { color: 'w', from: 'g2', to: 'g3', piece: 'p', san: 'g3' }\n```\n\n#### .move() - Permissive Parser\n\nThe permissive (default) move parser can be used to parse a variety of\nnon-standard move notations. Users may specify an `{ strict: true }` flag to\nverify that all supplied moves adhere to the Standard Algebraic Notation\nspecification.\n\n```ts\nconst chess = new Chess()\n\n// permissive parser accepts various forms of algebraic notation\nchess.move('e2e4')\nchess.move('e7-e5')\nchess.move('Pf2-f4')\nchess.move('ef4') // missing 'x' in capture\nchess.move('Ng1-f3')\nchess.move('d7xd6') // ignore 'x' when not a capture\nchess.move('d4')\n\n// correctly parses incorrectly disambiguated moves\nchess.load('r2qkbnr/ppp2ppp/2n5/1B2pQ2/4P3/8/PPP2PPP/RNB1K2R b KQkq - 3 7')\n\nchess.move('Nge7') // Ne7 is unambiguous because the knight on c6 is pinned\nchess.undo()\nchess.move('Nge7', { strict: true }) // strict SAN requires Ne7\n// Error: Invalid move: Nge7\n```\n\n### .moveNumber()\n\nReturns the current move number.\n\n```ts\nchess.load('4r1k1/p1prnpb1/Pp1pq1pp/3Np2P/2P1P3/R4N2/1PP2PP1/3QR1K1 w - - 2 20')\nchess.moveNumber()\n// -> 20\n```\n\n### .moves({ piece?: Piece, square?: Square, verbose = false} = {})\n\nReturns a list of legal moves from the current position. This function takes an\noptional object which can be used to generate detailed move objects or to\nrestrict the move generator to specific squares or pieces.\n\n```ts\nconst chess = new Chess()\nchess.moves()\n// -> ['a3', 'a4', 'b3', 'b4', 'c3', 'c4', 'd3', 'd4', 'e3', 'e4',\n//     'f3', 'f4', 'g3', 'g4', 'h3', 'h4', 'Na3', 'Nc3', 'Nf3', 'Nh3']\n\nchess.moves({ square: 'e2' }) // single square move generation\n// -> ['e3', 'e4']\n\nchess.moves({ piece: 'n' }) // generate moves for piece type\n// ['Na3', 'Nc3', 'Nf3', 'Nh3']\n\nchess.moves({ verbose: true }) // return verbose moves\n// -> [{ color: 'w', from: 'a2', to: 'a3',\n//       piece: 'p',\n//       san: 'a3', lan: 'a2a3',\n//       before: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n//       after: 'rnbqkbnr/pppppppp/8/8/8/P7/1PPPPPPP/RNBQKBNR b KQkq - 0 1'\n//       # a `captured` field is included when the move is a capture\n//       # a `promotion` field is included when the move is a promotion\n//     },\n//     ...\n//     ]\n```\n\n#### Move Object (e.g. when { verbose: true })\n\nThe `color` field indicates the color of the moving piece (`w` or `b`).\n\nThe `from` and `to` fields are from and to squares in algebraic notation.\n\nThe `piece`, `captured`, and `promotion` fields contain the lowercase\nrepresentation of the applicable piece (`pnbrqk`). The `captured` and\n`promotion` fields are only present when the move is a valid capture or\npromotion.\n\nThe `san` field is the move in Standard Algebraic Notation (SAN). The `lan`\nfield is the move in Long Algebraic Notation (LAN).\n\nThe `before` and `after` keys contain the FEN of the position before and after\nthe move.\n\nThe `Move` object has helper methods that describe the type of move:\n\n- `.isCapture()` - is the move a regular capture? NOTE: this is `false` for an\n  en-passant capture\n- `.isEnPassant()` - is the move an en-passant capture?\n- `.isBigPawn()` - is the move a 2-rank pawn move?\n- `.isPromotion()` - is the move a pawn promotion?\n- `.isKingsideCastle()` - is the move a kingside castle?\n- `.isQueensideCastle()` - is the move a queenside castle?\n\n### .pgn([ options ])\n\nReturns the game in PGN format. Options is an optional parameter which may\ninclude max width and/or a newline character settings.\n\n```ts\nconst chess = new Chess()\nchess.setHeader('White', 'Plunky')\nchess.setHeader('Black', 'Plinkie')\nchess.move('e4')\nchess.move('e5')\nchess.move('Nc3')\nchess.move('Nc6')\n\nchess.pgn({ maxWidth: 5, newline: '<br />' })\n// -> '[White \"Plunky\"]<br />[Black \"Plinkie\"]<br /><br />1. e4 e5<br />2. Nc3 Nc6'\n```\n\n### .put(piece, square)\n\nPlace a piece on the square where piece is an object with the form { type: ...,\ncolor: ... }. Returns true if the piece was successfully placed, otherwise, the\nboard remains unchanged and false is returned. `put()` will fail when passed an\ninvalid piece or square, or when two or more kings of the same color are placed.\n\n```ts\nchess.clear()\n\nchess.put({ type: PAWN, color: BLACK }, 'a5') // put a black pawn on a5\n// -> true\nchess.put({ type: 'k', color: 'w' }, 'h1') // shorthand\n// -> true\n\nchess.fen()\n// -> '8/8/8/p7/8/8/8/7K w - - 0 0'\n\nchess.put({ type: 'z', color: 'w' }, 'a1') // invalid piece\n// -> false\n\nchess.clear()\n\nchess.put({ type: 'k', color: 'w' }, 'a1')\n// -> true\n\nchess.put({ type: 'k', color: 'w' }, 'h1') // fail - two kings\n// -> false\n```\n\n### .remove(square)\n\nRemove and return the piece on _square_. Returns `undefined` if the square is\nalready empty.\n\n```ts\nchess.clear()\nchess.put({ type: PAWN, color: BLACK }, 'a5') // put a black pawn on a5\nchess.put({ type: KING, color: WHITE }, 'h1') // put a white king on h1\n\nchess.remove('a5')\n// -> { type: 'p', color: 'b' },\nchess.remove('h1')\n// -> { type: 'k', color: 'w' },\nchess.remove('e1')\n// -> undefined\n```\n\n### .removeComment()\n\nDelete and return the comment for the current position, if it exists.\n\n```ts\nconst chess = new Chess()\n\nchess.loadPgn('1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *')\n\nchess.getComment()\n// -> \"giuoco piano\"\n\nchess.removeComment()\n// -> \"giuoco piano\"\n\nchess.getComment()\n// -> undefined\n```\n\n### .removeComments()\n\nDelete and return comments for all positions.\n\n```ts\nconst chess = new Chess()\n\nchess.loadPgn(\n  \"1. e4 e5 {king's pawn opening} 2. Nf3 Nc6 3. Bc4 Bc5 {giuoco piano} *\",\n)\n\nchess.removeComments()\n// -> [\n//     {\n//       fen: \"rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2\",\n//       comment: \"king's pawn opening\"\n//     },\n//     {\n//       fen: \"r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3\",\n//       comment: \"giuoco piano\"\n//     }\n//    ]\n\nchess.getComments()\n// -> []\n```\n\n### .removeHeader(field: string): boolean\n\nRemove a field from the PGN header. Returns `true` if the header was removed,\nelse `false` as the header was not found.\n\n```ts\nchess.setHeader('White', 'Morphy')\nchess.setHeader('Black', 'Anderssen')\nchess.setHeader('Date', '1858-??-??')\nchess.removeHeader('Date')\nchess.getHeaders()\n// -> { White: 'Morphy', Black: 'Anderssen'}\n```\n\n### .reset()\n\nReset the board to the initial starting position.\n\n### .setCastlingRights(color, rights)\n\nSets the castling rights for the given color. Returns true if the change was\nsuccessfully made. False will be returned when the position doesn't allow the\nrequested change i.e. if the corresponding king or rook is not on it's starting\nsquare.\n\n```ts\n// white can't castle kingside but can castle queenside\nchess.setCastlingRights(WHITE, { [KING]: false, [QUEEN]: true })\n```\n\n### .setComment(comment)\n\nComment on the current position.\n\n```ts\nconst chess = new Chess()\n\nchess.move('e4')\nchess.setComment(\"king's pawn opening\")\n\nchess.pgn()\n// -> \"1. e4 {king's pawn opening}\"\n```\n\n### .setHeader(key: string, value: string): Record<string, string>\n\nSet a header key/value pair to be added to the PGN output.\n\n```ts\nchess.setHeader('White', 'Robert James Fischer')\n// { 'White': 'Robert James Fischer' }\nchess.setHeader('Black', 'Mikhail Tal')\n// { 'White': 'Robert James Fischer', 'Black': 'Mikhail Tal' }\n```\n\n### .setTurn(color)\n\nSets the side to move. If the color is changed it returns true, if the color\nremains unchanged it returns false. If a player is in check, attempting to\nchange the color to turn will throw an exception.\n\n```ts\nchess.setTurn('b')\n// -> true\nchess.setTurn('b')\n// -> false\n```\n\n### .squareColor(square)\n\nReturns the color of the square ('light' or 'dark').\n\n```ts\nconst chess = Chess()\nchess.squareColor('h1')\n// -> 'light'\nchess.squareColor('a7')\n// -> 'dark'\nchess.squareColor('bogus square')\n// -> null\n```\n\n### .turn()\n\nReturns the current side to move.\n\n```ts\nchess.load('rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1')\nchess.turn()\n// -> 'b'\n```\n\n### .undo()\n\nTakeback the last half-move, returning a move object if successful, otherwise\nnull.\n\n```ts\nconst chess = new Chess()\n\nchess.fen()\n// -> 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\nchess.move('e4')\nchess.fen()\n// -> 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1'\n\nchess.undo()\n//  {\n//    color: 'w',\n//    piece: 'p',\n//    from: 'e2',\n//    to: 'e4',\n//    san: 'e4',\n//    flags: 'b',\n//    lan: 'e2e4',\n//    before: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',\n//    after: 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1'\n//  }\n\nchess.fen()\n// -> 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\nchess.undo()\n// -> null\n```\n\n### validateFen(fen):\n\nThis static function returns a validation object specifying validity or the\nerrors found within the FEN string.\n\n```ts\nimport { validateFen } from 'chess.js'\n\nvalidateFen('2n1r3/p1k2pp1/B1p3b1/P7/5bP1/2N1B3/1P2KP2/2R5 b - - 4 25')\n// -> { ok: true }\n\nvalidateFen('4r3/8/X12XPk/1p6/pP2p1R1/P1B5/2P2K2/3r4 w - - 1 45')\n// -> { ok: false,\n//     error: '1st field (piece positions) is invalid [invalid piece].' }\n```\n",
    "description": "[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/jhlywa/chess.js/node.js.yml)](https://github.com/jhlywa/chess.js/actions) [![npm](https://img.shields.io/npm/v/chess.js?color=blue)](https://www.npmjs.com/package/chess.js) [![npm](https://img.shields.io/npm/dm/chess.js)](https://www.npmjs.com/package/chess.js)",
    "licenseText": "Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/chess.js/-/chess.js-1.4.0.tgz#edc1439492d1a0d7f530ba72b2b5398baece28a1",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/chess.js/-/chess.js-1.4.0.tgz",
    "hash": "edc1439492d1a0d7f530ba72b2b5398baece28a1",
    "integrity": "sha512-BBJgrrtKQOzFLonR0l+k64A98NLemPwNsCskwb+29bRwobUa4iTm51E1kwGPbWXAcfdDa18nad6vpPPKPWarqw==",
    "registry": "npm",
    "packageName": "chess.js",
    "cacheIntegrity": "sha512-BBJgrrtKQOzFLonR0l+k64A98NLemPwNsCskwb+29bRwobUa4iTm51E1kwGPbWXAcfdDa18nad6vpPPKPWarqw== sha1-7cFDlJLRoNf1MLpysrU5i67OKKE="
  },
  "registry": "npm",
  "hash": "edc1439492d1a0d7f530ba72b2b5398baece28a1"
}